#!/usr/bin/env ruby

require 'json'
require 'pathname'

# given a list of attributes
# returns a function which expects a file or stat object and will answer
# true if all of the attributes are true about that object
def filters (list)
  ok = %w{blockdev chardev directory file pipe setgid setuid socket sticky
    symlink world_readable world_writable zero}
  ok = ok + ok.map {|i| '!'+i}
  not_ok = list - ok
  raise "unsupported: '#{not_ok}'" if not_ok.length > 0
  list.map! {|i| i = i+'?';
    i.sub!(/^!/, '') ? ->(f) {not(f.send(i))} : ->(f){f.send(i)}
  }
  return ->(f) { return list.all? {|t| t.call(f)} ? true : false }
end

# should prep the report per key (so it can be prepped once, stored and
# re-run in persistent mode)
def report (key, c)
  path = Pathname.new(c[:path] || key.to_s)

  sf = [] # list of checks which must all return true per stat
  sf.push(filters(c[:filters])) if c[:filters]
  sf.push(->(p) {
    p = /#{p}$/
    ->(s) { sprintf("%04o", s.mode & 0777) =~ p }
  }.call(c[:permissions])) if c[:permissions]
  # TODO for atime,mtime,ctime, size
  # TODO uid,gid

  no_stat = c[:no_list] && sf.length == 0 # OPTIMIZATION

  nf = [] # list of checks which must all return true per name
  if c[:skip]
    nf.push(->(list){
      skips = Hash[list.map {|n| [n,true]}]
      return ->(f) { skips[f.to_s] ? false : true }
    }.call(c[:skip]))
    warn "'skip' and 'only' options nonsensical" if c[:only]
  end


  # TODO I think lstat is the way to go - assumes you want to know about
  # symlinks more than their targets (make it an option?)

  files = Hash[
  c[:only] ?
    c[:only].map {|f| [f, begin; path.+(f).lstat; rescue; nil; end]} :
  ->(got) { no_stat ?
      got.map {|f| [f.to_s, nil]}
    : got.map {|f| [f.to_s, path.+(f).lstat]}
  }.call(
    c[:glob] ?
      Pathname.glob(path + c[:glob]).map {|n| n.relative_path_from(path)} :
    c[:match] ?
      path.children(false).find_all {|x| x.to_s =~ /#{c[:match]}/o}
    : path.children(false)
  )]
  files.keep_if {|f,s| nf.all? {|c| c.call(f)} } if nf.length > 0
  files.keep_if {|f,s| sf.all? {|c| c.call(s)} } if sf.length > 0

  res = {count: files.keys.length}
  return res if c[:no_list]
  res.merge('' => Hash[files.map {|k,v|
    [k,v ? Hash[
      %w{dev ino mode nlink uid gid rdev size blksize blocks}
      .map {|n| [n,v.send(n)]} +
      %w{atime mtime ctime}.map {|n| [n,v.send(n).to_i]}] : nil]
  }])
end

def run (opt)
  p = opt[:paths] or raise "'paths' argument required!"

  puts JSON.generate(Hash[p.map {|k,v| [k, report(k,v)]}])
end

run(JSON::parse(ARGV[0], {symbolize_names: true})) if __FILE__ == $0
